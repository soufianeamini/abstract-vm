# Abstract-Vm

The purpose of this project is to create a simple virtual machine that can interpret programs written in a basic assembly language.

## How to build

You will need to have the following dependencies installed on your system:
* clang
* ninja
* cmake

Run the command `cmake -GNinja -Bbuild` to generate the build directory with a build.ninja file.
The step above only needs to be executed once.

Next, in order to compile (or recompile) the project (after changes in either the source code or CMakeLists.txt), run:
```bash
cd build/
ninja
```

The project will take care of installing dependencies along with compiling the project.

## How to run

First, make sure you are inside the `build/` directory.

1. 
```bash
./avm
```

The avm will read from standard input and interpret code after each ';;' token.

2.
```bash
./avm ../avm-tests/example.avm
```

The avm will read the file and execute the instructions in it provided the assembly code is correct.

## How to run tests

There are two tests: Unit tests and integration tests.

1. Unit tests
To run unit tests, make sure to uncomment the `#define DEBUG` line at the top of the main.cpp file. Then run `make run`.

2. Integration tests
In order to run integration tests, make sure the line `#define DEBUG` at the top of main.cpp is commented out.
Then run the following commands:
```bash
python -m venv .venv
source .venv/bin/activate
pip install ward
ward -p tests/
```

## Features

This project features multiple things:

### Virtual Machine

AVM is a stack based virtual machine that can interpret an assembly language with a limited and explicit type system.

### .avm files

.avm are files that contain assembly code that respects the grammar dictated in grammar.txt.

### Errors

Files containing syntax error will not be interpreted.
An .avm file needs to contain an exit instruction.

### Formatter

To run the formatter, you can execute the following command:

```bash
./amv --format <.avm-file>
```

The output is a nicely formatted .avm file, and you can redirect the output to whatever file you want.

## Implementation details

The project is implemented using a Lexer/Parser couple, and a Vm class that interprets the instructions generated by the parser.
It executes mathematical operations following an infix notation, and it checks for overflows and underflows.
It is compiled with -std=c++17.
